<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Index</title>
</head>

<body>
  Index-jello
  <div id='app'>
    <div> {{arr}}</div>
    <div id="my" class="aaa" class=bbb>hello {{name}} <span>world</span></div>
    <ul>
      <li>{{school.name}}</li>
      <li>{{school.age}}</li>
    </ul>
  </div>
  <script src="./dist/umd/vue.js"></script>

  <script>
    // console.log('Vue---->', Vue)
    // options: API 通过一个选项进行配置(会有很多问题)
    let vm = new Vue({
      el: '#app',
      data() {
        return { arr: [1, 2, 3], shool: { name: 'zf', age: 10 } }
      },
      template: "<div id='app'>hello {{name}} <span>world</span></div>",
      // render(h) {
      //   // 类似react的createElement
      //   return h('div', { id: a }, 'hello')
      // },
      watch: '',
      computed: ''
    })
    console.log('vm.$options', vm.$options, 'vm._data', vm._data.arr[0])
    // 默认弄个数据会递归去用defineproperty进行拦截，性能差 --> proxy
    // 观测的如果是数组的索引，开发功能时很少对数组索引进行操作，为了性能考虑不对数组进行拦截(数组数据量太大)
    // 拦截可以改变数组的方法进行操作
    // 操作数组一般用push pop shift方法， 这些方法会改变原数组，拦截这些可以改变数组的方法的操作，当调用这些方法的时候，再通知数据变化了
    // 很少有这样的操作，arr[997] = 100

    // 渲染的操作 1）默认会先找render方法 2) 默认没有传入render方法会查找template 3）找当前el指定的元素中的内容来进行渲染 ast解析template => render函数

    console.log('vm.arr', vm.arr)
    vm.arr = 100

  </script>
</body>

</html>